---
title: "Financial Time Series"
mode: "wide"
---

<Note>
  This model identifies directional trends by predicting how likely price action in the selected timeframe will propagate to lower-frequency timeframes, distinguishing structurally significant market moves from noise.
</Note>

<Tip>
  We recommend using higher frequency data compared to your target forecast horizon, as this leverages the model's propagation methodology effectively (e.g., use 15 or 30 min data to predict daily moves).
</Tip>

## Key Concepts

<AccordionGroup>
  <Accordion title="Cross-Timeframe Connectivity">
    The reasoning model operates as a unified system where predictions across multiple time horizons work together rather than independently. This integrated approach reveals how market movements propagate across timeframes, uncovering interconnected relationships that traditional single-timeframe approaches fundamentally cannot detect.

    <img
      height="200"
      src="/images/Unified System Architecture.png"
    />
  </Accordion>
  <Accordion title="High-to-Low Frequency Propagation Assumption">
    The reasoning model assumes that all price movements originate in high-frequency time series before cascading into lower-frequency time series. Therefore, the model analyses price action and only returns trends that it believes will propagate into lower frequency timeframes.
  </Accordion>
  <Accordion title="Interpreting Trend Context">
    The reasoning model begins its analysis with as little as 10 historical data points. Your results include both the forecast (if identified) and the trend context that shaped it, all in one view. This helps users understand if predictions occur at the beginning, middle, or end of broader trends, making forecasts easier to understand and increasing your confidence in decisions.
  </Accordion>
  <Accordion title="Interpreting Trend Signals">
    Each forecast should be interpreted within its trend context: the first signal in a consecutive trend marks the start of a trend, while consecutive forecasts in the same direction indicate the consistency of the current trend.
  </Accordion>
  <Accordion title="Immediate Insights, Custom Optimisation">
    The reasoning model delivers immediate market insights without requiring market-specific training data. While predictive out of the box, it can be fine-tuned to optimise performance for specific time horizons through customised post-training. This flexibility allows users to incorporate multiple timeframes or any combination of traditional and alternative datasets of their choosing.
  </Accordion>
  <Accordion title="Request Processing">
    API requests are processed in a FIFO (first-in, first-out) on a shared server, with each request taking approximately 1-2 seconds to complete. Wait times may extend during high-usage periods. For usage without queue delays, contact us at [team@sumtyme.ai](mailto:team@sumtyme.ai) to arrange a dedicated environment.
  </Accordion>
</AccordionGroup>

## API Data Structure

<AccordionGroup>
  <Accordion title="Input">
    ```json

    {
    "datetime": [
        "2005-08-30 00:00:00",
        "2005-08-31 00:00:00",
        "2005-09-01 00:00:00",
        "2005-09-02 00:00:00",
        "2005-09-05 00:00:00",
        ...,
        "2025-06-12 00:00:00",
        "2025-06-13 00:00:00",
        "2025-06-16 00:00:00",
        "2025-06-17 00:00:00",
        "2025-06-18 00:00:00"
    ],
    "open": [
        5228.10009765625,
        5255.7998046875,
        5296.89990234375,
        5328.5,
        5326.7998046875,
        ...,
        8864.400390625,
        8884.900390625,
        8850.599609375,
        8875.2001953125,
        0.0
    ],
    "high": [
        5270.2001953125,
        5300.0,
        5342.10009765625,
        5338.10009765625,
        5341.7998046875,
        ...,
        8896.900390625,
        8898.599609375,
        8902.400390625,
        8875.2001953125,
        0.0
    ],
    "low": [
        5228.10009765625,
        5255.7998046875,
        5296.89990234375,
        5319.60009765625,
        5320.60009765625,
        ...,
        8843.599609375,
        8822.2001953125,
        8850.599609375,
        8809.900390625,
        0.0
    ],
    "close": [
        5255.7998046875,
        5296.89990234375,
        5328.5,
        5326.89990234375,
        5337.7998046875,
        ...,
        8884.900390625,
        8850.599609375,
        8875.2001953125,
        8834.0,
        0.0
    ],
    "interval": 1,
    "interval_unit": "days",
    "reasoning_mode": "reactive"
}
    
    ```
  </Accordion>
  <Accordion title="Output">
    ```json
    {
    "2007-10-11T00:00:00": {
        "trend_identified": 1.0
    },
    "2007-11-08T00:00:00": {
        "trend_identified": 1.0
    },
    "2007-11-14T00:00:00": {
        "trend_identified": 1.0
    },
    "2008-07-29T00:00:00": {
        "trend_identified": -1.0
    },
    "2008-08-07T00:00:00": {
        "trend_identified": -1.0
    },
    
    ...
    
    "2025-06-12T00:00:00": {
        "trend_identified": -1.0
    },
    "2025-06-13T00:00:00": {
        "trend_identified": -1.0
    },
    "2025-06-16T00:00:00": {
        "trend_identified": -1.0
    },
    "2025-06-17T00:00:00": {
        "trend_identified": -1.0
    },
    "2025-06-18T00:00:00": {
        "trend_identified": -1.0
    }
    }
    ```
  </Accordion>
</AccordionGroup>



## Yahoo Finance Example

<AccordionGroup>
  <Accordion title="Signup">
    ```python
    import pandas as pd
    import requests 
    
    def signup_user(endpoint_url: str, email: str, password: str, confirm_password: str):
      """
      Calls the /signup endpoint, handles the response, and saves the API key to a .txt file.
    
      Args:
          endpoint_url (str): The URL of your /signup endpoint.
          company_id (str): The company ID for the new user.
          email (str): The email address for the new user.
          password (str): The password for the new user.
          confirm_password (str): The password confirmation for the new user.
      """
    
      payload = {
          "email": email,
          "password": password,
          "confirm_password": confirm_password
      }
      headers = {
          "Content-Type": "application/json"
      }
    
      # Make the POST request to the signup endpoint
      response = requests.post(endpoint_url, data=json.dumps(payload), headers=headers)
      response.raise_for_status()  # Raise an HTTPError for bad responses (4xx or 5xx)
    
      response_data = response.json()
    
      if response.status_code == 200:
          api_key = response_data.get("api_key")
          user_email = response_data.get("email")
          message = response_data.get("message")
    
          if api_key:
              # Define the filename for the API key
              filename = f"api_key_{user_email.replace('@', '_').replace('.', '_')}.txt"
              with open(filename, "w") as f:
                  f.write(api_key)
              print(f"Success: {message}")
              print(f"API Key for {user_email} saved to {filename}")
              return {"success": True, "api_key": api_key, "filename": filename}
          else:
              print(f"Error: Signup successful but no API key found in response. Response: {response_data}")
              return {"success": False, "message": "API key not found in response"}
      else:
          # Handle other success status codes if necessary
          print(f"Unexpected successful response status code: {response.status_code}. Response: {response_data}")
          return {"success": False, "message": "Unexpected successful response"}
    
    signup_endpoint = "https://www.sumtyme.tech/signup"
    
    # Example signup data
    user_email = ""
    user_password = ""
    confirm_user_password = ""
    
    result = signup_user(signup_endpoint, user_email, user_password, confirm_user_password)
    
    ```
  </Accordion>
  <Accordion title="Download AAPL Daily Price Data">
    ```python
    
    import yfinance as yf
    import pandas as pd
    
    def daily(ticker_name, period):
      """
      Fetches historical stock data for a given ticker, period, and interval,
      then processes and renames the columns for consistency.
    
      Args:
          ticker_name (str): The stock ticker symbol (e.g., "AAPL").
          period (str): The period for which to fetch data (e.g., "1d", "5d", "1mo", "1y", "max").
    
      Returns:
          pd.DataFrame: A DataFrame containing the processed historical price data
                        with 'datetime', 'open', 'high', 'low', 'close' columns.
      """
      # Create a Ticker object for the given ticker symbol
      ticker = yf.Ticker(ticker_name)
    
      # Fetch historical data using the specified period and interval
      data = ticker.history(period=period, interval="1d")
    
      # Reset the index of the DataFrame. 'Date' will become a regular column instead of the index.
      data = data.reset_index(drop=False)
    
      # Select only the relevant columns: 'Date', 'Open', 'High', 'Low', 'Close'
      data = data[['Date', 'Open', 'High', 'Low', 'Close']]
    
      # Remove timezone information from the 'Date' column to simplify datetime handling.
      data['Date'] = data['Date'].dt.tz_localize(None)
    
      # Rename columns to a more consistent, lowercase format
      data.rename(columns={'Date': 'datetime', 'Open': 'open', 'High': 'high', 'Low': 'low', 'Close': 'close'}, inplace=True)
    
      # Convert the 'datetime' column to a standardised string format "%Y-%m-%d %H:%M:%S"
      data['datetime'] = pd.to_datetime(data['datetime'], format="%Y-%m-%d").dt.strftime("%Y-%m-%d %H:%M:%S")
    
      # Return the processed DataFrame
      return data
    
    ticker_name = "AAPL"
    period = "max"
    price_data = daily(ticker_name, period)
    
    # For this example, predict the last row
    price_data.loc[price_data.index[-1], ['open', 'high', 'low', 'close']] = 0
    print(price_data)

    # Save APPL data to csv file
    price_data.to_csv('AAPL_Daily.csv',index=False)
    
    ```
  </Accordion>
  <Accordion title="Make POST request">
    ```python

    # Import Price Data
    price_data = pd.read_csv('AAPL_Daily.csv')
    
    # Select Last 5001 rows
    last_5001_rows = price_data.tail(5001)
    
    print(f"Forecasting whether a trend has been identified for {last_5001_rows['datetime'].iloc[-1]}...")
    
    # Define Analysis Parameters
    interval = 1
    interval_unit = 'days'
    reasoning_mode = 'reactive'
    
    # Payload Construction
    payload = time_series_dict(last_5001_rows, interval, interval_unit, reasoning_mode)
    
    # Financial Time Series API Endpoint
    url = "https://www.sumtyme.tech/agn-reasoning/ts"
    
    # Send API Request
    response = requests.post(url, json=payload,headers={"Content-Type": "application/json","X-API-Key":userdata.get('apikey')})
    
    # Processing the API Response
    response_dict = response.json()
    
    # Convert Response to DataFrame
    analysis = dict_to_dataframe(response_dict)
    print(analysis)
    
    # Save Analysis to .csv file
    analysis.to_csv('returned_analysis.csv',index=False)
        
    
    ```
  </Accordion>
</AccordionGroup>


## Full Script

<AccordionGroup>
  <Accordion title="Example Python Script">
    ```python
    
    # Install required libraries
    import requests
    import json
    import yfinance as yf
    import pandas as pd
    from datetime import datetime, timedelta
    import os 
    from dotenv import load_dotenv
    
    load_dotenv()
    
    
    def signup_user(endpoint_url: str, email: str, password: str, confirm_password: str):
      """
      Calls the /signup endpoint, handles the response, and saves the API key to a .txt file.
      
      Args:
          endpoint_url (str): The URL of your /signup endpoint.
          company_id (str): The company ID for the new user.
          email (str): The email address for the new user.
          password (str): The password for the new user.
          confirm_password (str): The password confirmation for the new user.
      """
      
      payload = {
          "email": email,
          "password": password,
          "confirm_password": confirm_password
      }
      headers = {
          "Content-Type": "application/json"
      }
      
      # Make the POST request to the signup endpoint
      response = requests.post(endpoint_url, data=json.dumps(payload), headers=headers)
      # response.raise_for_status()  # Raise an HTTPError for bad responses (4xx or 5xx)
      
      response_data = response.json()
      
      if response.status_code == 200:
          api_key = response_data.get("api_key")
          user_email = response_data.get("email")
          message = response_data.get("message")
      
          if api_key:
              # Define the filename for the API key
              filename = f"api_key_{user_email.replace('@', '_').replace('.', '_')}.txt"
              with open(filename, "w") as f:
                  f.write(api_key)
              print(f"Success: {message}")
              print(f"API Key for {user_email} saved to {filename}")
              return {"success": True, "api_key": api_key, "filename": filename}
          else:
              return {"success": False, "message": "API key not found in response"}
      else:
          # Handle other success status codes if necessary
          return {"success": False, "message": "Unexpected successful response", "Response": response_data}
    
    
    def daily(ticker_name, period):
      """
      Fetches historical stock data for a given ticker, period, and interval,
      then processes and renames the columns for consistency.
    
      Args:
          ticker_name (str): The stock ticker symbol (e.g., "AAPL").
          period (str): The period for which to fetch data (e.g., "1d", "5d", "1mo", "1y", "max").
    
      Returns:
          pd.DataFrame: A DataFrame containing the processed historical price data
                        with 'datetime', 'open', 'high', 'low', 'close' columns.
      """
      # Create a Ticker object for the given ticker symbol
      ticker = yf.Ticker(ticker_name)
    
      # Fetch historical data using the specified period and interval
      data = ticker.history(period=period, interval="1d")
    
      # Reset the index of the DataFrame. 'Date' will become a regular column instead of the index.
      data = data.reset_index(drop=False)
    
      # Select only the relevant columns: 'Date', 'Open', 'High', 'Low', 'Close'
      data = data[['Date', 'Open', 'High', 'Low', 'Close']]
    
      # Remove timezone information from the 'Date' column to simplify datetime handling.
      data['Date'] = data['Date'].dt.tz_localize(None)
    
      # Rename columns to a more consistent, lowercase format
      data.rename(columns={'Date': 'datetime', 'Open': 'open', 'High': 'high', 'Low': 'low', 'Close': 'close'}, inplace=True)
    
      # Convert the 'datetime' column to a standardised string format "%Y-%m-%d %H:%M:%S"
      data['datetime'] = pd.to_datetime(data['datetime'], format="%Y-%m-%d").dt.strftime("%Y-%m-%d %H:%M:%S")
    
      # Return the processed DataFrame
      return data
    
    
    def time_series_dict(df, interval, interval_unit, reasoning_mode):
      """
      Converts a DataFrame with OHLC price data into a dictionary format.
    
      Parameters:
      df (DataFrame): DataFrame containing datetime and OHLC price columns
      interval (int): The time interval between data points
      interval_unit (str): The unit of time for intervals (seconds, minutes, days)
      reasoning_mode (str): Reasoning strategy (proactive or reactive)
    
      Returns:
      dict: Dictionary with lists of datetime and price data along with metadata
      """
      return {
          "datetime": df['datetime'].tolist(),  # Convert datetime column to list
          "open": df['open'].tolist(),          # Convert open prices to list
          "high": df['high'].tolist(),          # Convert high prices to list
          "low": df['low'].tolist(),            # Convert low prices to list
          "close": df['close'].tolist(),        # Convert close prices to list
          "interval": interval,                 # Time frequency value
          "interval_unit": interval_unit,       # Time unit (seconds, minutes, days)
          "reasoning_mode": reasoning_mode      # Reasoning approach (proactive/reactive)
      }
    
    
    def dict_to_dataframe(response_dict):
    
      """
      Convert a nested dictionary to a pandas DataFrame with datetime and trend data.
      
      Takes a dictionary where keys are timestamp strings and values are dictionaries
      containing 'trend_identified' data. Returns a sorted DataFrame with datetime
      and trend_identified columns.
      
      Args:
         response_dict (dict): Dictionary with timestamp keys and nested dictionaries
                              containing 'trend_identified' values
      
      Returns:
         pd.DataFrame: DataFrame with 'datetime' and 'trend_identified' columns,
                      sorted by datetime in ascending order
      """
      
      # Create lists for datetime and trend_identified values
      datetimes = []
      trends = []
      
      # Extract values from the nested dictionary
      for timestamp, data in response_dict.items():
        datetimes.append(timestamp)
        trends.append(data['trend_identified'])
      
      # Create the DataFrame
      df = pd.DataFrame({
        'datetime': datetimes,
        'trend_identified': trends
      })
      
      # Convert datetime strings to pandas datetime objects
      df['datetime'] = pd.to_datetime(df['datetime'])
      
      # Sort by datetime
      df = df.sort_values('datetime')

      return df
    
    
    signup_endpoint = "https://www.sumtyme.tech/signup"
    
    # Example signup data
    user_email = ""
    user_password = ""
    confirm_user_password = ""
    
    result = signup_user(signup_endpoint, user_email, user_password, confirm_user_password)
    
    ticker_name = "AAPL"
    period = "max"
    price_data = daily(ticker_name, period)
    
    # For this example, predict if a trend exists for the last period
    price_data.loc[price_data.index[-1], ['open', 'high', 'low', 'close']] = 0
    
    # Select Last 5001 rows
    last_5001_rows = price_data.tail(5001)
    
    print(f"Forecasting whether a trend has been identified for {last_5001_rows['datetime'].iloc[-1]}...")
    
    # Define Analysis Parameters
    interval = 1
    interval_unit = 'days'
    reasoning_mode = 'reactive'
    
    # Payload Construction
    payload = time_series_dict(last_5001_rows, interval, interval_unit, reasoning_mode)
    
    # Financial Time Series API Endpoint
    url = "https://www.sumtyme.tech/agn-reasoning/ts"
    
    # Send API Request
    response = requests.post(url, json=payload,headers={"Content-Type": "application/json","X-API-Key":os.environ.get('apikey')})
    
    # Processing the API Response
    response_dict = response.json()
    
    # Convert Response to DataFrame
    analysis = dict_to_dataframe(response_dict)
    print(analysis)
    
    # Save Analysis to .csv file
    analysis.to_csv('returned_analysis.csv',index=False)
    
    
    
    
    
    ```
  </Accordion>
</AccordionGroup>
