---
title: 'Reasoning Model API: Developer Guide'
---

## üöÄ Quick Start Guide

Want to jump right in? Here's how to start making API calls in minutes:

```python
import pandas as pd
import requests

# 1. Load your market data
df = pd.read_csv("your_price_data.csv")

# 2. Ensure your data has datetime, open, high, low, close columns
df['datetime'] = pd.to_datetime(df['datetime'])

# 3. Make API call with the last 5000 entries
df_window = df.tail(5000)
df_window['datetime'] = df_window['datetime'].dt.strftime('%Y-%m-%d %H:%M:%S')

# 4. Create payload
payload = {
    "datetime": df_window['datetime'].tolist(),
    "open": df_window['open'].tolist(),
    "high": df_window['high'].tolist(),
    "low": df_window['low'].tolist(),
    "close": df_window['close'].tolist(),
    "interval": 1,  # 1-minute data
    "interval_unit": "minutes",
    "reasoning_mode": "reactive"
}

# 5. Call API
response = requests.post(
    "https://www.sumtyme.com/shared/v1/reasoning-model-ts",
    json=payload,
    headers={"Content-Type": "application/json"}
)

# 6. Get task ID and log it
task_id = response.json().get("task_id")
print(f"Task ID: {task_id}")
```

## üìã What You'll Learn
By the end of this guide, you'll be able to:

- Prepare financial time series data for the API
- Make API calls to get market trend predictions
- Process API responses and track prediction tasks
- Implement walk-forward testing for historical analysis

## üìö Table of Contents

- Understanding the Reasoning Model
- Setting Up Your Environment
- Data Preparation
- Making API Calls
- Tracking Results
- Full Implementation
- Practical Examples
- Troubleshooting

## üß† Understanding the Reasoning Model
The reasoning model identifies directional trends by predicting how likely price action in the selected timeframe will propagate to lower-frequency timeframes, distinguishing structurally significant market moves from noise.

Key Benefits:

‚úÖ Filters out market noise
‚úÖ Provides higher-conviction signals
‚úÖ Works across different market regimes
‚úÖ Anticipates significant market moves

## üõ†Ô∏è Setting Up Your Environment

### What You Need

- Python 3.6 or higher
- Market data with OHLC (Open, High, Low, Close) values
- Internet connection to access the API

### Installation
Install the required packages:

```python

pip install pandas numpy requests

```

## üìä Data Preparation

### Data Format Requirements

Your market data must include these columns:

- datetime: Timestamp for each price point
- open: Opening price
- high: Highest price during the period
- low: Lowest price during the period
- close: Closing price

### Sample Data Preparation

```python 
import pandas as pd

# Load your data
df = pd.read_csv("market_data.csv")

# Ensure datetime is properly formatted
df['datetime'] = pd.to_datetime(df['datetime'])

# Check your data
print(df.head())
```

### Creating Data Windows

The API works best with windows of 5000 data points. Here's a simple utility to create these windows:

```python
def create_moving_window(data, window_size=5000, step_size=1):
    """
    Creates windows of data for API processing
    
    Parameters:
    -----------
    data : DataFrame
        Your market data
    window_size : int
        Size of each window (default: 5000)
    step_size : int
        Step size between windows (default: 5000)
    """
    if not isinstance(data, pd.DataFrame) or data.empty:
        raise ValueError("Data must be a non-empty DataFrame")
    
    # Check required columns
    required_columns = ['datetime', 'open', 'high', 'low', 'close']
    if not all(col in data.columns for col in required_columns):
        missing = [col for col in required_columns if col not in data.columns]
        raise ValueError(f"Missing required columns: {missing}")
    
    # Create windows
    windows = []
    for i in range(0, len(data) - window_size + 1, step_size):
        windows.append(data.iloc[i:i + window_size].copy())
    
    return windows

```

## üîå Making API Calls

### Step 1: Prepare your payload

```python
def create_payload(df, interval, interval_unit):
    """
    Creates API payload from DataFrame
    
    Parameters:
    -----------
    df : DataFrame
        Window of OHLC data
    interval : int
        Time interval (e.g., 1 for 1 minute)
    interval_unit : str
        'seconds', 'minutes', or 'days'
    """
    # Format datetime strings for API
    df_copy = df.copy()
    df_copy['datetime'] = pd.to_datetime(df_copy['datetime']).dt.strftime('%Y-%m-%d %H:%M:%S')
    
    return {
        "datetime": df_copy['datetime'].tolist(),
        "open": df_copy['open'].tolist(),
        "high": df_copy['high'].tolist(),
        "low": df_copy['low'].tolist(),
        "close": df_copy['close'].tolist(),
        "interval": interval,
        "interval_unit": interval_unit,
        "reasoning_mode": "reactive"
    }
```

### Step 2: Call the API

```python

def call_api(payload):
    """
    Makes API call and returns task_id
    """
    api_endpoint = "https://www.sumtyme.com/shared/v1/reasoning-model-ts"
    headers = {"Content-Type": "application/json"}
    
    response = requests.post(api_endpoint, json=payload, headers=headers)
    
    if response.status_code != 200:
        print(f"API call failed: {response.status_code} - {response.text}")
        return None
    
    return response.json().get("task_id")
```

## üìù Tracking Results

Create a simple logging system to track your API calls and results:

```python 
import os
from datetime import datetime

def log_task_id(task_id, forecast_date, filename="api_calls.csv"):
    """
    Logs task ID to CSV file
    """
    # Create file with headers if it doesn't exist
    if not os.path.exists(filename):
        with open(filename, 'w') as f:
            f.write("timestamp,forecast_date,task_id,checked\n")
    
    # Log the task ID
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    with open(filename, 'a') as f:
        f.write(f"{current_time},{forecast_date},{task_id},blank\n")

```

## üíª Full Implementation

Here's how all the pieces fit together:

```python
import pandas as pd
import numpy as np
import requests
import json
import os
from datetime import datetime

def create_moving_window(data, window_size=5000, step_size=5000):
    """Creates windows of data for API processing"""
    if not isinstance(data, pd.DataFrame) or data.empty:
        raise ValueError("Data must be a non-empty DataFrame")
    
    required_columns = ['datetime', 'open', 'high', 'low', 'close']
    if not all(col in data.columns for col in required_columns):
        missing = [col for col in required_columns if col not in data.columns]
        raise ValueError(f"Missing required columns: {missing}")
    
    windows = []
    for i in range(0, len(data) - window_size + 1, step_size):
        windows.append(data.iloc[i:i + window_size].copy())
    
    return windows

def create_payload(df, interval, interval_unit):
    """Creates API payload from DataFrame"""
    df_copy = df.copy()
    df_copy['datetime'] = pd.to_datetime(df_copy['datetime']).dt.strftime('%Y-%m-%d %H:%M:%S')
    
    return {
        "datetime": df_copy['datetime'].tolist(),
        "open": df_copy['open'].tolist(),
        "high": df_copy['high'].tolist(),
        "low": df_copy['low'].tolist(),
        "close": df_copy['close'].tolist(),
        "interval": interval,
        "interval_unit": interval_unit,
        "reasoning_mode": "reactive"
    }

def log_task_id(task_id, forecast_date, filename="api_calls.csv"):
    """Logs task ID to CSV file"""
    if not os.path.exists(filename):
        with open(filename, 'w') as f:
            f.write("timestamp,forecast_date,task_id,checked\n")
    
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    with open(filename, 'a') as f:
        f.write(f"{current_time},{forecast_date},{task_id},blank\n")

def process_dataset(df, interval, interval_unit, log_filename):
    """
    Process entire dataset in windows
    
    Parameters:
    -----------
    df : DataFrame
        Your market data
    interval : int
        Time interval (e.g., 1 for 1 minute)
    interval_unit : str
        'seconds', 'minutes', or 'days'
    log_filename : str
        File to log task IDs
    """
    # Create windows of data
    windows = create_moving_window(df)
    print(f"Created {len(windows)} data windows")
    
    # Process each window
    for i, window in enumerate(windows):
        print(f"Processing window {i+1}/{len(windows)}")
        
        # Get forecast date (last timestamp in window)
        forecast_date = window['datetime'].iloc[-1]
        
        # Create payload
        payload = create_payload(window, interval, interval_unit)
        
        try:
            # Call API
            api_endpoint = "https://www.sumtyme.com/shared/v1/reasoning-model-ts"
            headers = {"Content-Type": "application/json"}
            
            response = requests.post(api_endpoint, json=payload, headers=headers)
            
            if response.status_code != 200:
                print(f"API call failed: {response.status_code} - {response.text}")
                continue
                
            # Get task ID
            task_id = response.json().get("task_id")
            
            # Log task ID
            log_task_id(task_id, forecast_date, log_filename)
            
        except Exception as e:
            print(f"Error processing window {i+1}: {str(e)}")

# Usage example
if __name__ == "__main__":
    # Load your data
    df = pd.read_csv("market_data.csv")
    df['datetime'] = pd.to_datetime(df['datetime'])
    
    # Set parameters
    interval = 1          # 1 for 1 minute data
    interval_unit = "minutes"  # 'seconds', 'minutes', or 'days'
    log_filename = "task_ids.csv"
    
    # Process dataset
    process_dataset(df, interval, interval_unit, log_filename)
```

## üîç Practical Examples

### Example 1: Processing 1-Second SPY Data

```python 
# Load SPY data
df = pd.read_csv("spy_1sec_data.csv")
df['datetime'] = pd.to_datetime(df['datetime'])

# Process with 1-second intervals
process_dataset(df, interval=1, interval_unit="seconds", log_filename="spy_1sec_task_ids.csv")
```

### Example 2: Checking Task Status

After submitting your data, you can check task status:

```python 
def check_task_status(task_id):
    """Check the status of a submitted task"""
    api_endpoint = f"https://www.sumtyme.com/shared/v1/task/{task_id}"
    
    response = requests.get(api_endpoint)
    if response.status_code == 200:
        return response.json()
    else:
        print(f"Failed to retrieve task status: {response.status_code}")
        return None

# Example usage
task_id = "your-task-id-here"
status = check_task_status(task_id)
print(status)
```

## ‚ö†Ô∏è Troubleshooting

### Common Issues

1. API Returns 4xx Error

- Check your data format, especially datetime formatting
- Ensure all required fields are present in your payload


Empty Response

Verify your internet connection
Ensure the API endpoint URL is correct


Performance Issues

Try reducing your window size if processing is slow
Process windows in parallel for large datasets



## Best Practices

- Data Validation: Always validate your data before sending to the API
- Error Handling: Implement robust error handling for API calls
- Logging: Log all API interactions for troubleshooting
- Rate Limiting: Space out your API calls to avoid hitting rate limits

## üìà Case Studies

### Trump Tariff Market Shock (April 2025)

The reasoning model provided early warning signals before a major market shock:

| Time Series | Signal Time | Market Event | Lead Time |
|-------------|-------------|--------------|-----------|
| 1 minute | 2025-04-02 10:30:00 | April 2nd 2025 - 4pm EST | 5.5 hours |
| 5 minute | 2025-04-02 10:30:00 | April 2nd 2025 - 4pm EST | 5.5 hours |
| 15 minute | 2025-04-02 10:30:00 | April 2nd 2025 - 4pm EST | 5.5 hours |

This real-world example demonstrates how the model can provide valuable advance warning of significant market moves.


