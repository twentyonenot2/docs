---
title: "Reasoning Model - Time Series Data"
---

<Note>
  This model identifies directional trends by predicting how likely price action in the selected timeframe will propagate to lower-frequency timeframes, distinguishing structurally significant market moves from noise.
</Note>

<Tip>
  We recommend using higher frequency data compared to your target forecast horizon, as this leverages the model's propagation methodology effectively (e.g., use 15 or 30 min data to predict daily moves).
</Tip>

## Time Series Data

<AccordionGroup>
  <Accordion title="Import CSV Data">
    ```python
    import pandas as pd
    
    df = pd.read_csv("filename.csv")[['datetime','open','high','low','close']]
    
    print(df)
    
    ```
  </Accordion>
  <Accordion title="Download Sample Data">
    ```python
    import requests
    import pandas as pd
    import io
    
    def download_github_data(url):
    
        # Convert GitHub repo URL to raw content URL
        if "github.com" in url and "/blob/" not in url and "/tree/" in url:
        
            # For /tree/ links, convert to raw
            url = url.replace("github.com", "raw.githubusercontent.com")
            url = url.replace("/tree/", "/")
            
        elif "github.com" in url and "/blob/" in url:
        
            # For /blob/ links, convert to raw
            url = url.replace("github.com", "raw.githubusercontent.com")
            url = url.replace("/blob/", "/")
            
        print(f"Downloading from: {url}")
        
        response = requests.get(url)
        
        if response.status_code == 200:
        
            return pd.read_csv(io.StringIO(response.text))
        
        else:
        
            raise Exception(f"Failed to download data: {response.status_code}")
    
    # Example usage
    github_url = "https://github.com/sumtyme-ade/sample_data/tree/main/sample/spy_etf_1min.csv"
    market_data = download_github_data(github_url)
    print(f"Downloaded {len(market_data)} rows of data")
    ```
  </Accordion>
</AccordionGroup>

## Data Preparation

<AccordionGroup>
  <Accordion title="Create JSON Payload - 1 API Call">
    ```python
    # Import required libraries
    import pandas as pd
    import json
    
    def time_series_dict(df, interval, interval_unit, reasoning_mode):
        """
        Converts a DataFrame with OHLC price data into a dictionary format.
        
        Parameters:
        df (DataFrame): DataFrame containing datetime and OHLC price columns
        interval (int): The time interval between data points
        interval_unit (str): The unit of time for intervals (seconds, minutes, days)
        reasoning_mode (str): Reasoning strategy (proactive or reactive)
        
        Returns:
        dict: Dictionary with lists of datetime and price data along with metadata
        """
        return {
            "datetime": df['datetime'].tolist(),  # Convert datetime column to list
            "open": df['open'].tolist(),          # Convert open prices to list
            "high": df['high'].tolist(),          # Convert high prices to list
            "low": df['low'].tolist(),            # Convert low prices to list
            "close": df['close'].tolist(),        # Convert close prices to list
            "interval": interval,                 # Time frequency value
            "interval_unit": interval_unit,       # Time unit (seconds, minutes, days)
            "reasoning_mode": reasoning_mode      # Reasoning approach (proactive/reactive)
        }
    
    # Read the CSV file and select only the required columns
    df = pd.read_csv("filename.csv")[['datetime', 'open', 'high', 'low', 'close']]
    
    # Set the time interval between data points
    interval = 1 
    
    # Set the unit of time for the interval (options: seconds, minutes, days)
    interval_unit = "minutes"
    
    # Set the reasoning mode (options: proactive or reactive)
    reasoning_mode = "reactive"
    
    # Create the JSON-compatible dictionary from the DataFrame and parameters
    json_payload = time_series_dict(df, interval, interval_unit, reasoning_mode)
    
    ```
  </Accordion>
  <Accordion title="Create JSON Payload - Multiple API Calls">
    ```python
    # Import required libraries
    import pandas as pd
    import json
    
    def time_series_dict(df, interval, interval_unit, reasoning_mode):
        """
        Converts a DataFrame with OHLC price data into a dictionary format.
        
        Parameters:
        df (DataFrame): DataFrame containing datetime and OHLC price columns
        interval (int): The time interval between data points
        interval_unit (str): The unit of time for intervals (seconds, minutes, days)
        reasoning_mode (str): Reasoning strategy (proactive or reactive)
        
        Returns:
        dict: Dictionary with lists of datetime and price data along with metadata
        """
        return {
            "datetime": df['datetime'].tolist(),  # Convert datetime column to list
            "open": df['open'].tolist(),          # Convert open prices to list
            "high": df['high'].tolist(),          # Convert high prices to list
            "low": df['low'].tolist(),            # Convert low prices to list
            "close": df['close'].tolist(),        # Convert close prices to list
            "interval": interval,                 # Time frequency value
            "interval_unit": interval_unit,       # Time unit (seconds, minutes, days)
            "reasoning_mode": reasoning_mode      # Reasoning approach (proactive/reactive)
        }
    
    # Read the CSV file and select only the required columns
    df = pd.read_csv("filename.csv")[['datetime', 'open', 'high', 'low', 'close']]
    
    # Set the time interval between data points
    interval = 1 
    
    # Set the unit of time for the interval (options: seconds, minutes, days)
    interval_unit = "minutes"
    
    # Set the reasoning mode (options: proactive or reactive)
    reasoning_mode = "reactive"
    
    # Split data for efficient submission
    chunk_size = 5000
    df_list = [df.iloc[i:i+chunk_size] for i in range(0, len(df), chunk_size)]
    
    # Create API-ready payloads for each data chunk
    json_payloads = [time_series_dict(chunk, interval, interval_unit, reasoning_mode) for chunk in df_list]
    
    ```
  </Accordion>
</AccordionGroup>

## Make API Request

<AccordionGroup>
  <Accordion title="Submit Data to API - 1 API Call">
    ```python
    import pandas as pd
    import json
    import os
    from datetime import datetime
    
    def log_forecast_check(task_id, forecast_date, log_file="sumtyme_task_ids.log"):
        """
        Logs a forecast check to a CSV file.
        
        Parameters:
        - task_id (str): The ID of the task 
        - forecast_date (str): The date of the forecast
        - log_file (str): Path to the log file, defaults to "sumtyme_task_ids.log"
        """
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Create log file with header if it doesn't exist
        if not os.path.exists(log_file):
            with open(log_file, 'w') as f:
                f.write("timestamp,forecast_date,task_id,checked\n")
    
        # Write to log file
        with open(log_file, 'a') as f:
            f.write(f"{current_time},{forecast_date},{task_id},blank\n")
        
        return True
    
    def time_series_dict(df,interval,interval_unit,reasoning_mode):
    
      return {
          "datetime": df['datetime'].tolist(),
          "open": df['open'].tolist(),
          "high": df['high'].tolist(),
          "low": df['low'].tolist(),
          "close": df['close'].tolist(),
          "interval": interval,
          "interval_unit":interval_unit,
          "reasoning_mode":reasoning_mode
      }
    
    def post_request(df,interval,interval_unit,reasoning_mode):
    
      # Prepare request
      api_endpoint = f"https://www.sumtyme.com/shared/v1/reasoning-model-ts"
      headers = {"Content-Type": "application/json"}
      
      # Create payload from data
      payload = time_series_dict(df,interval,interval_unit,reasoning_mode)
      
      # Send POST request to API
      response = requests.post(api_endpoint, json=payload, headers=headers)
    
      if response.status_code != 200:
        print(f"API request failed for {forecast_date} with status code {response.status_code}: {response.text}")
      else:
        return response.json()
    
    df = pd.read_csv("filename.csv")[['datetime','open','high','low','close']].tail(5000)
    
    forecast_date = df['datetime'].iloc[-1]
    
    interval = 1 
    
    interval_unit = "minutes" # options: seconds,minutes,days
    
    reasoning_mode = "reactive" # options: proactive or reactive
    
    response = post_request(df,interval,interval_unit,reasoning_mode)
    
    if response:
    
      task_id = response.get("task_id")
    
      log_forecast_check(task_id,forecast_date)
        
    ```
  </Accordion>
</AccordionGroup>

## Sandbox API Response

<AccordionGroup>
  <Accordion title="Get Task ID">
    ```python
    
        
    ```
  </Accordion>
</AccordionGroup>

## Retrieve Analysis

<AccordionGroup>
  <Accordion title="Using Log File">
    ```python
    
    
    import pandas as pd
    import requests
    
    def check_task_status(task_id):
      """Check the status of a submitted task"""
      api_endpoint = f"https://www.sumtyme.com/results/{task_id}"
      
      # Make the API request
      response = requests.get(api_endpoint)
      
      # Check if the request was successful (status code 200)
      if response.status_code == 200:
          result_data = response.json()
          
          # Check if processing is complete
          if "status" in result_data and result_data["status"] == "complete":
              return result_data
      
      # If we get here, either the request failed or status wasn't complete
      print(f"Failed to retrieve task status for {task_id}: {response.status_code}")
      return None
    
    def dict_to_dataframe(response_dict):
      """Transform response dictionary to dataframe more efficiently"""
      # Extract the result dictionary
      result_dict = response_dict['result']
      
      # Create the DataFrame directly from the dictionary
      df = pd.DataFrame([
          {'datetime': timestamp, 'trend_identified': data['trend_identified']}
          for timestamp, data in result_dict.items()
      ])
      
      # Convert datetime strings to pandas datetime objects
      df['datetime'] = pd.to_datetime(df['datetime'])
      
      # Sort by datetime
      return df.sort_values('datetime').reset_index(drop=True)
    
    def get_analysis(dataset, save_filename):
      """Process the dataset and check task statuses"""
      # Create a copy of the dataset to update
      updated_dataset = dataset.copy()
      
      # Pre-allocate the 'checked' column with default value
      updated_dataset['checked'] = 'Not processed'
      
      # Process each row in the dataset
      for i in dataset.index:
          try:
              # Extract data for current row
              task_id = str(dataset.loc[i, 'task_id'])
              forecast_date = pd.to_datetime(dataset.loc[i, 'forecast_date'])
              
              # Get analysis results
              analysis_results = check_task_status(task_id)
              
              # Process results if available
              if analysis_results is not None and 'result' in analysis_results:
                  # Convert results to DataFrame
                  df_results = dict_to_dataframe(analysis_results)
                  
                  # Check if dataframe has data
                  if not df_results.empty:
                      # Get the last datetime and trend in the results
                      last_datetime = df_results['datetime'].iloc[-1]
                      trend = df_results['trend_identified'].iloc[-1]
                      
                      # Update the 'checked' column based on datetime match
                      if last_datetime == forecast_date:
                          updated_dataset.loc[i, 'checked'] = trend
                      else:
                          updated_dataset.loc[i, 'checked'] = 'No'
                  else:
                      updated_dataset.loc[i, 'checked'] = 'Empty results'
              else:
                  updated_dataset.loc[i, 'checked'] = 'No results'
                  
          except Exception as e:
              # Improved error handling with exception details
              print(f"Error processing task_id {task_id}: {str(e)}")
              updated_dataset.loc[i, 'checked'] = 'Error'
      
      # Save the updated dataset
      updated_dataset.to_csv(save_filename, index=False)
      print(f"Processing complete. Results saved to {save_filename}")
    
    filename = "spy_1_min_task_ids"
    input_file = f"{filename}.csv"
    save_filename = f"{filename}_checked.csv"
        
    # Load the dataset
    dataset = pd.read_csv(input_file)
    
    get_analysis(dataset, save_filename)
      
        
    ```
  </Accordion>
  <Accordion title="Using Task ID">
    ```python
    
    
    import pandas as pd
    import requests
    
    def check_task_status(task_id):
      """Check the status of a submitted task"""
      api_endpoint = f"https://www.sumtyme.com/results/{task_id}"
      
      # Make the API request
      response = requests.get(api_endpoint)
      
      # Check if the request was successful (status code 200)
      if response.status_code == 200:
          result_data = response.json()
          
          # Check if processing is complete
          if "status" in result_data and result_data["status"] == "complete":
              return result_data
    
          elif "status" in result_data and result_data["status"] == "processing":
               print(f"{task_id}: Still processing") 
               return None
      
      # If we get here, either the request failed or status wasn't complete
      print(f"Failed to retrieve task status for {task_id}: {response.status_code}")
      return None
    
    def dict_to_dataframe(response_dict):
      """Transform response dictionary to dataframe more efficiently"""
      # Extract the result dictionary
      result_dict = response_dict['result']
      
      # Create the DataFrame directly from the dictionary
      df = pd.DataFrame([
          {'datetime': timestamp, 'trend_identified': data['trend_identified']}
          for timestamp, data in result_dict.items()
      ])
      
      # Convert datetime strings to pandas datetime objects
      df['datetime'] = pd.to_datetime(df['datetime'])
      
      # Sort by datetime
      return df.sort_values('datetime').reset_index(drop=True)
    
              
    
    task_id = ""
    
    result = check_task_status(task_id)
    
    if result is not None:
    
      final = dict_to_dataframe(response_dict)
    
      final.to_csv("sumtyme_analysis.csv",index=False)
    
        
    ```
  </Accordion>
</AccordionGroup>

## Plot Forecasts

<AccordionGroup>
  <Accordion title="Merge Price Data and Log File/Saved DataFrame">
    ```python
    
        
    ```
  </Accordion>
  <Accordion title="Plot Data">
    ```python
    
    import plotly.graph_objects as go
    from plotly.subplots import make_subplots
    import pandas as pd
    
    def create_line_chart_with_signals(df, name):
        """
        Create a full-screen trading signals chart with close price line and positioned arrows.
        
        Args:
            df (pd.DataFrame): DataFrame with Datetime, Close, and trend_identified columns
        """
        # Data validation and cleaning
        if not isinstance(df, pd.DataFrame):
            raise ValueError("Input must be a pandas DataFrame")
            
        required_cols = ['datetime', 'close', 'trend_identified']
        if not all(col in df.columns for col in required_cols):
            raise ValueError(f"DataFrame must contain columns: {required_cols}")
        
        # Ensure Datetime is properly formatted and sort
        df = df.copy()
        df['Datetime'] = pd.to_datetime(df['datetime']).dt.strftime("%Y-%m-%d %H:%M:%S")
        df = df.sort_values('datetime')
        print(df)
        # Create figure
        fig = make_subplots(specs=[[{"secondary_y": True}]])
        
        # Add line chart for close prices
        fig.add_trace(
            go.Scatter(
                x=df['datetime'],
                y=df['close'],
                mode='lines',
                name="Close Price",
                line=dict(
                    color='#2C3E50',
                    width=2
                )
            ),
            secondary_y=False,
        )
      
        # Calculate offset for arrow positioning
        price_range = df['high'].max() - df['low'].min()
        arrow_offset = price_range * 0.0  # 2% of price range for arrow positioning
      
        # Configure signals with error handling
        signal_configs = [
            # (signal value, name, color, symbol, offset direction)
            (1, 'Bullish Trend', '#7CFC00', 'triangle-up', -1),  # Below candle
            (-1, 'Bearish Trend', '#FF0000', 'triangle-down', 1)  # Above candle
        ]
        
        # Add signal markers with positioned arrows
        for signal, signal_name, color, symbol, offset_dir in signal_configs:
            signal_df = df[df['trend_identified'] == signal]
            if not signal_df.empty:
                # Calculate arrow positions based on Close price
                y_positions = signal_df['close'] + (arrow_offset * offset_dir)
                
                fig.add_trace(
                    go.Scatter(
                        x=signal_df['datetime'],
                        y=y_positions,
                        mode='markers',
                        name=signal_name,
                        marker=dict(
                            symbol=symbol,
                            size=12,
                            color=color,
                            opacity=0.7,
                        ),
                        hovertemplate='Signal: ' + signal_name + '<br>' +
                                    'Price: %{y:.2f}<br>' +
                                    '%{x}<extra></extra>'
                    ),
                    secondary_y=False,
                )
      
        # Optimize y-axis range with additional padding for arrows
        close_min = df['close'].min()
        close_max = df['close'].max()
        price_range = close_max - close_min
        padding = price_range * 0.05  # 5% padding
        y_range = [
            close_min - padding,
            close_max + padding
        ]
        
        # Create custom x-axis ticks with just first, middle, and last
        first_date = df['datetime'].iloc[0]
        middle_date = df['datetime'].iloc[len(df) // 2]
        last_date = df['datetime'].iloc[-1]
        
        custom_ticks = [first_date, middle_date, last_date]
        
        # Update layout for full screen
        fig.update_layout(
            title=dict(
                text=f'{name}',
                x=0.5,
                y=0.98,
                xanchor='center',
                yanchor='top',
                font=dict(size=20)
            ),
            plot_bgcolor='white',
            paper_bgcolor='white',
            hovermode='x unified',
            height=1200,
            width=None,
            margin=dict(l=40, r=20, t=50, b=60),  # Increased bottom margin for horizontal dates
            legend=dict(
                bgcolor='rgba(255, 255, 255, 0.9)',
                bordercolor='black',
                borderwidth=1,
                orientation='h',
                yanchor='top',
                y=0.98,
                xanchor='left',
                x=0.02,
                font=dict(size=12),
                itemsizing='constant'
            ),
            showlegend=True,
            xaxis_rangeslider_visible=False
        )
      
        # Update axes with custom ticks and horizontal date format
        fig.update_xaxes(
            title_text="Time",
            showgrid=True,
            gridwidth=1,
            gridcolor='rgba(211,211,211,0.2)',
            zeroline=False,
            showline=True,
            linewidth=1,
            linecolor='black',
            tickfont=dict(size=16),
            tickangle=0,  # Horizontal text
            tickmode='array',
            tickvals=custom_ticks,
            tickformat='%Y-%m-%d %H:%M',
            type='category',
        )
      
        fig.update_yaxes(
            title_text="Price",
            showgrid=True,
            gridwidth=1,
            gridcolor='rgba(211,211,211,0.2)',
            zeroline=False,
            showline=True,
            linewidth=1,
            linecolor='black',
            tickprefix='',
            tickformat='.1f',
            tickfont=dict(size=16),
            range=y_range,
            secondary_y=False
        )
      
        return fig
    
    filename = "sumtyme_predictions"
    
    df = pd.read_csv(f"{filename}.csv")
    
    fig = create_line_chart_with_signals(df,f"{filename}")
    
    fig.show()
    
    
        
    ```
  </Accordion>
</AccordionGroup>

## Full Script

<AccordionGroup>
  <Accordion title="Single API Call">
    ```python
    
        
    ```
  </Accordion>
  <Accordion title="Multiple API Calls">
    ```python
    
        
    ```
  </Accordion>
</AccordionGroup>

## Performance Evaluation

<AccordionGroup>
  <Accordion title="Predictive Lead Time">
    Quantify how many minutes/hours/days before major market events the model provides reliable signals, demonstrating its ability to anticipate systemic shifts before they fully develop in the market.
  </Accordion>
  <Accordion title="Reaction Speed">
    Measure how quickly the model adjusts after sudden market shocks, calculated as the time between a shock event and when the model's predictions catch up to the new reality.
  </Accordion>
  <Accordion title="Time Horizon Alignment">
    Verify that predictions for neighbouring time periods (e.g. 1 hour, 2 hour, 3 hour) consistently build upon each other without logical contradictions or conflicting signals.
  </Accordion>
</AccordionGroup>

## Key Concepts

<AccordionGroup>
  <Accordion title="Cross-Timeframe Connectivity">
    The reasoning model operates as a unified system where predictions across multiple time horizons work together rather than independently. This integrated approach reveals how market movements propagate across timeframes, uncovering interconnected relationships that traditional single-timeframe approaches fundamentally cannot detect.

    <img
      height="200"
      src="/images/Unified System Architecture.png"
    />
  </Accordion>
  <Accordion title="High-to-Low Frequency Propagation Assumption">
    The reasoning model assumes that all price movements originate in high-frequency time series before cascading into lower-frequency time series. It therefore analyses price action and only returns trends that it believes will translate into lower frequency timeframes.
  </Accordion>
  <Accordion title="Interpreting Trend Context">
    The reasoning model begins its analysis with as little as 10 historical data points. Your results include both the forecast (if identified) and the trend context that shaped it, all in one view. This helps users understand if predictions occur at the beginning, middle, or end of broader trends, making forecasts easier to understand and increasing your confidence in decisions.
  </Accordion>
  <Accordion title="Interpreting Trend Signals">
    Each forecast should be interpreted within its trend context: the first signal in a consecutive trend marks the start of a trend, while consecutive forecasts in the same direction indicate the consistency of the current trend.
  </Accordion>
  <Accordion title="Immediate Insights, Custom Optimisation">
    The reasoning model delivers immediate market insights without requiring market-specific training data. While predictive out of the box, it can be fine-tuned to optimise performance for specific time horizons through customised post-training. This flexibility allows users to incorporate multiple timeframes or any combination of traditional and alternative datasets of their choosing.
  </Accordion>
  <Accordion title="Sandbox Queue System">
    The sandbox processes API requests in a FIFO (first-in, first-out) queue, with each request taking approximately 5 seconds to complete. Wait times may extend during high-usage periods. For testing without queue delays, contact us at [team@sumtyme.ai](mailto:team@sumtyme.ai) to arrange a dedicated environment.
  </Accordion>
</AccordionGroup>