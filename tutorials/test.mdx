---
title: "Reasoning Model - Time Series Data"
mode: "wide"
---

<Note>
  This model identifies directional trends by predicting how likely price action in the selected timeframe will propagate to lower-frequency timeframes, distinguishing structurally significant market moves from noise.
</Note>

<Tip>
  We recommend using higher frequency data compared to your target forecast horizon, as this leverages the model's propagation methodology effectively (e.g., use 15 or 30 min data to predict daily moves).
</Tip>

## Time Series Data

<AccordionGroup>
  <Accordion title="Import CSV Data">
    ```python
    import pandas as pd
    
    df = pd.read_csv("filename.csv")[['datetime','open','high','low','close']]
    
    print(df)
    
    ```
  </Accordion>
  <Accordion title="Download Sample Data">
    ```python
    import requests
    import pandas as pd
    import io
    
    def download_github_data(url):
    
        # Convert GitHub repo URL to raw content URL
        if "github.com" in url and "/blob/" not in url and "/tree/" in url:
        
            # For /tree/ links, convert to raw
            url = url.replace("github.com", "raw.githubusercontent.com")
            url = url.replace("/tree/", "/")
            
        elif "github.com" in url and "/blob/" in url:
        
            # For /blob/ links, convert to raw
            url = url.replace("github.com", "raw.githubusercontent.com")
            url = url.replace("/blob/", "/")
            
        print(f"Downloading from: {url}")
        
        response = requests.get(url)
        
        if response.status_code == 200:
        
            return pd.read_csv(io.StringIO(response.text))
        
        else:
        
            raise Exception(f"Failed to download data: {response.status_code}")
    
    # Example usage
    github_url = "https://github.com/sumtyme-ade/sample_data/tree/main/sample/spy_etf_1min.csv"
    df = download_github_data(github_url)
    print(f"Downloaded {len(df)} rows of data")
    ```
  </Accordion>
</AccordionGroup>

## Data Preparation

<AccordionGroup>
  <Accordion title="Create JSON Payload - 1 API Call">
    ```python
    # Import required libraries
    import pandas as pd
    import json
    
    def time_series_dict(df, interval, interval_unit, reasoning_mode):
        """
        Converts a DataFrame with OHLC price data into a dictionary format.
        
        Parameters:
        df (DataFrame): DataFrame containing datetime and OHLC price columns
        interval (int): The time interval between data points
        interval_unit (str): The unit of time for intervals (seconds, minutes, days)
        reasoning_mode (str): Reasoning strategy (proactive or reactive)
        
        Returns:
        dict: Dictionary with lists of datetime and price data along with metadata
        """
        return {
            "datetime": df['datetime'].tolist(),  # Convert datetime column to list
            "open": df['open'].tolist(),          # Convert open prices to list
            "high": df['high'].tolist(),          # Convert high prices to list
            "low": df['low'].tolist(),            # Convert low prices to list
            "close": df['close'].tolist(),        # Convert close prices to list
            "interval": interval,                 # Time frequency value
            "interval_unit": interval_unit,       # Time unit (seconds, minutes, days)
            "reasoning_mode": reasoning_mode      # Reasoning approach (proactive/reactive)
        }
    
    # Read the CSV file and select only the required columns
    df = pd.read_csv("filename.csv")[['datetime', 'open', 'high', 'low', 'close']]
    
    # Set the time interval between data points
    interval = 1 
    
    # Set the unit of time for the interval (options: seconds, minutes, days)
    interval_unit = "minutes"
    
    # Set the reasoning mode (options: proactive or reactive)
    reasoning_mode = "reactive"
    
    # Create the JSON-compatible dictionary from the DataFrame and parameters
    json_payload = time_series_dict(df, interval, interval_unit, reasoning_mode)
    
    ```
  </Accordion>
  <Accordion title="Create JSON Payload - Multiple API Calls">
    ```python
    # Import required libraries
    import pandas as pd
    import json
    
    def time_series_dict(df, interval, interval_unit, reasoning_mode):
        """
        Converts a DataFrame with OHLC price data into a dictionary format.
        
        Parameters:
        df (DataFrame): DataFrame containing datetime and OHLC price columns
        interval (int): The time interval between data points
        interval_unit (str): The unit of time for intervals (seconds, minutes, days)
        reasoning_mode (str): Reasoning strategy (proactive or reactive)
        
        Returns:
        dict: Dictionary with lists of datetime and price data along with metadata
        """
        return {
            "datetime": df['datetime'].tolist(),  # Convert datetime column to list
            "open": df['open'].tolist(),          # Convert open prices to list
            "high": df['high'].tolist(),          # Convert high prices to list
            "low": df['low'].tolist(),            # Convert low prices to list
            "close": df['close'].tolist(),        # Convert close prices to list
            "interval": interval,                 # Time frequency value
            "interval_unit": interval_unit,       # Time unit (seconds, minutes, days)
            "reasoning_mode": reasoning_mode      # Reasoning approach (proactive/reactive)
        }
    
    # Read the CSV file and select only the required columns
    df = pd.read_csv("filename.csv")[['datetime', 'open', 'high', 'low', 'close']]
    
    # Set the time interval between data points
    interval = 1 
    
    # Set the unit of time for the interval (options: seconds, minutes, days)
    interval_unit = "minutes"
    
    # Set the reasoning mode (options: proactive or reactive)
    reasoning_mode = "reactive"
    
    # Split data for efficient submission
    chunk_size = 5000
    df_list = [df.iloc[i:i+chunk_size] for i in range(0, len(df), chunk_size)]
    
    # Create API-ready payloads for each data chunk
    json_payloads = [time_series_dict(chunk, interval, interval_unit, reasoning_mode) for chunk in df_list]
    
    ```
  </Accordion>
</AccordionGroup>

## Make API Request

<AccordionGroup>
  <Accordion title="Submit Data to API - 1 API Call">
    ```python
    import pandas as pd
    import json
    import os
    from datetime import datetime
    
    def log_forecast_check(task_id, forecast_date, log_file="sumtyme_task_ids.log"):
        """
        Logs a forecast check to a CSV file.
        
        Parameters:
        - task_id (str): The ID of the task 
        - forecast_date (str): The date of the forecast
        - log_file (str): Path to the log file, defaults to "sumtyme_task_ids.log"
        """
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Create log file with header if it doesn't exist
        if not os.path.exists(log_file):
            with open(log_file, 'w') as f:
                f.write("timestamp,forecast_date,task_id,checked\n")
    
        # Write to log file
        with open(log_file, 'a') as f:
            f.write(f"{current_time},{forecast_date},{task_id},blank\n")
        
        return True
    
    def time_series_dict(df, interval, interval_unit, reasoning_mode):
        """
        Converts a DataFrame with OHLC price data into a dictionary format.
        
        Parameters:
        df (DataFrame): DataFrame containing datetime and OHLC price columns
        interval (int): The time interval between data points
        interval_unit (str): The unit of time for intervals (seconds, minutes, days)
        reasoning_mode (str): Reasoning strategy (proactive or reactive)
        
        Returns:
        dict: Dictionary with lists of datetime and price data along with metadata
        """
        return {
            "datetime": df['datetime'].tolist(),  # Convert datetime column to list
            "open": df['open'].tolist(),          # Convert open prices to list
            "high": df['high'].tolist(),          # Convert high prices to list
            "low": df['low'].tolist(),            # Convert low prices to list
            "close": df['close'].tolist(),        # Convert close prices to list
            "interval": interval,                 # Time frequency value
            "interval_unit": interval_unit,       # Time unit (seconds, minutes, days)
            "reasoning_mode": reasoning_mode      # Reasoning approach (proactive/reactive)
        }
    
    def post_request(df,interval,interval_unit,reasoning_mode):
    
      # Prepare request
      api_endpoint = f"https://www.sumtyme.com/shared/v1/reasoning-model-ts"
      headers = {"Content-Type": "application/json"}
      
      # Create payload from data
      payload = time_series_dict(df,interval,interval_unit,reasoning_mode)
      
      # Send POST request to API
      response = requests.post(api_endpoint, json=payload, headers=headers)
    
      if response.status_code != 200:
        print(f"API request failed for {forecast_date} with status code {response.status_code}: {response.text}")
      else:
        return response.json()
    
    #Import Data
    df = pd.read_csv("filename.csv")[['datetime','open','high','low','close']].tail(5000)
    
    # Get the last datetime as forecast date
    forecast_date = df['datetime'].iloc[-1]
    
    # Set the time interval between data points
    interval = 1 
    
    # Set the unit of time for the interval (options: seconds, minutes, days)
    interval_unit = "minutes"
    
    # Set the reasoning mode (options: proactive or reactive)
    reasoning_mode = "reactive"
    
    # Send request to API
    response = post_request(df,interval,interval_unit,reasoning_mode)
    
    # Process response if successful
    if response:
    
      task_id = response.get("task_id")
    
      log_forecast_check(task_id,forecast_date)
        
    ```
  </Accordion>
  <Accordion title="Multiple API Calls">
    ```python
      import requests
      import pandas as pd
      import io
      import os
      from datetime import datetime
      
      def download_github_data(url):
          # Convert GitHub repo URL to raw content URL
          if "github.com" in url and "/blob/" not in url and "/tree/" in url:
              # For /tree/ links, convert to raw
              url = url.replace("github.com", "raw.githubusercontent.com")
              url = url.replace("/tree/", "/")
          elif "github.com" in url and "/blob/" in url:
              # For /blob/ links, convert to raw
              url = url.replace("github.com", "raw.githubusercontent.com")
              url = url.replace("/blob/", "/")
              
          print(f"Downloading from: {url}")
          
          response = requests.get(url)
          if response.status_code == 200:
              return pd.read_csv(io.StringIO(response.text))
          else:
              raise Exception(f"Failed to download data: {response.status_code}")
      
      def time_series_dict(df, interval, interval_unit, reasoning_mode):
          """
          Converts a DataFrame with OHLC price data into a dictionary format.
          
          Parameters:
          df (DataFrame): DataFrame containing datetime and OHLC price columns
          interval (int): The time interval between data points
          interval_unit (str): The unit of time for intervals (seconds, minutes, days)
          reasoning_mode (str): Reasoning strategy (proactive or reactive)
          
          Returns:
          dict: Dictionary with lists of datetime and price data along with metadata
          """
          return {
              "datetime": df['datetime'].tolist(),  # Convert datetime column to list
              "open": df['open'].tolist(),          # Convert open prices to list
              "high": df['high'].tolist(),          # Convert high prices to list
              "low": df['low'].tolist(),            # Convert low prices to list
              "close": df['close'].tolist(),        # Convert close prices to list
              "interval": interval,                 # Time frequency value
              "interval_unit": interval_unit,       # Time unit (seconds, minutes, days)
              "reasoning_mode": reasoning_mode      # Reasoning approach (proactive/reactive)
          }
      
      def create_moving_window(data, window_size, step_size=1):
         """
         Creates a moving window for OHLC (Open, High, Low, Close) financial data.
         Optimized for speed using NumPy arrays.
         
         This function converts financial time series data into overlapping windows
         of fixed size, useful for rolling analysis, feature engineering, or 
         building datasets for machine learning models.
         
         Parameters:
         - data (pd.DataFrame or list): Input OHLC financial data
         - window_size (int): Number of time periods in each window
         - step_size (int, optional): Number of periods to advance for each new window, defaults to 1
         
         Returns:
         - list: List of DataFrame windows, each containing window_size rows of OHLC data
         
         Raises:
         - ValueError: If input data format is invalid, window_size is out of range,
                       step_size is not positive, or required columns are missing
         """
         
         # Validate input is a proper non-empty DataFrame
         if not isinstance(data, pd.DataFrame) or data.empty:
             raise ValueError("Data must be a non-empty DataFrame or list of dicts.")
         
         # Ensure window size is valid (positive and not larger than data)
         if window_size <= 0 or window_size > len(data):
             raise ValueError("Window size must be between 1 and length of data.")
         
         # Ensure step size is positive
         if step_size <= 0:
             raise ValueError("Step size must be greater than 0.")
         
         # Check that all required OHLC columns exist
         required_columns = ['datetime', 'open', 'high', 'low', 'close']
         if not all(col in data.columns for col in required_columns):
             missing = [col for col in required_columns if col not in data.columns]
             raise ValueError(f"Missing required columns: {missing}")
         
         # Filter to only keep essential columns for efficiency
         data = data[required_columns]
         
         # Convert to NumPy array for faster operations
         values = data.values
         
         # Calculate how many windows will be generated
         n_samples = (len(values) - window_size) // step_size + 1
         if n_samples <= 0:
             return []  # Return empty list if no complete windows can be formed
         
         # Create windows using list comprehension with fast NumPy slicing
         # Each window is a slice of the original data converted to DataFrame
         windows = [
             pd.DataFrame(values[i:i + window_size], columns=required_columns)
             for i in range(0, len(values) - window_size + 1, step_size)
         ]
         
         return windows
      
      def post_request(df, interval, interval_unit, reasoning_mode, log_file="sumtyme_task_ids.log"):
          """
          Sends time series data to API using a walk-forward approach with 5000-row chunks.
          
          Parameters:
          - df (DataFrame): Time series data with datetime and OHLC columns
          - interval (int): Time interval between data points
          - interval_unit (str): Unit of time interval (seconds, minutes, days)
          - reasoning_mode (str): Model reasoning mode (proactive, reactive)
          - filename (str): Base filename for logging results (without extension)
          
          Returns:
          - list: Collection of task IDs from successful API calls
          """
          
          # Check if file exists, if not create it with headers
          if not os.path.exists(log_file):
              with open(log_file, 'w') as f:
                  f.write("timestamp,forecast_date,task_id,trend_identified\n")
      
          # Define base API configuration
          BASE_URL = "https://www.sumtyme.com/shared"
          api_endpoint = f"{BASE_URL}/v1/reasoning-model-ts"
          headers = {"Content-Type": "application/json"}
      
          # Split data into 5000 row chunks
          df_chunks = create_moving_window(df, window_size=5000)
          
          task_ids = []  # Collect task IDs for return
      
          # Process each chunk with API calls
          for chunk in df_chunks:
      
              # Date to forecast for (last timestamp in chunk)
              forecast_date = chunk['datetime'].iloc[-1]
             
              # Convert datetime to proper format if needed
              chunk['datetime'] = pd.to_datetime(chunk['datetime']).dt.strftime('%Y-%m-%d %H:%M:%S')
      
              # Create payload from data
              payload = time_series_dict(chunk, interval, interval_unit, reasoning_mode)
      
              try:
                  # Send POST request to API
                  response = requests.post(api_endpoint, json=payload, headers=headers)
      
                  # Check for successful request
                  if response.status_code != 200:
                      print(f"API request failed for {forecast_date} with status code {response.status_code}: {response.text}")
                      continue
      
                  # Parse response
                  result = response.json()
                  task_id = result.get("task_id")
                  
                  if task_id:
                      task_ids.append(task_id)
            
                      # Get current timestamp for logging
                      current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                      
                      # Write to log file
                      with open(log_file, 'a') as f:
                          f.write(f"{current_time},{forecast_date},{task_id},0\n")
                          
                      print(f"Successfully processed forecast date {forecast_date}, task_id: {task_id}")
                  else:
                      print(f"Warning: No task ID returned for forecast date {forecast_date}")
                 
              except Exception as e:
                  # Log errors too
                  current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                  with open(log_file, 'a') as f:
                      f.write(f"{current_time},{forecast_date},ERROR: {str(e)},0\n")
                  print(f"Error processing forecast_date={forecast_date}: {str(e)}")
          
          return task_ids
      
      def check_task_status(task_id):
      
        """Check the status of a submitted task"""
      
        api_endpoint = f"https://www.sumtyme.com/results/{task_id}"
        
        # Make the API request
        response = requests.get(api_endpoint)
        
        # Check if the request was successful (status code 200)
        if response.status_code == 200:
            result_data = response.json()
            
            # Check if processing is complete
            if "status" in result_data and result_data["status"] == "complete":
                return result_data
      
            elif "status" in result_data and result_data["status"] == "processing":
                 print(f"{task_id}: Still processing") 
                 return None
        
        # If we get here, either the request failed or status wasn't complete
        print(f"Failed to retrieve task status for {task_id}: {response.status_code}")
        return None
      
      def dict_to_dataframe(response_dict):
        """
        Transform response dictionary to dataframe more efficiently
        """
        # Extract the result dictionary
        result_dict = response_dict['result']
        
        # Create the DataFrame directly from the dictionary
        df = pd.DataFrame([
            {'datetime': timestamp, 'trend_identified': data['trend_identified']}
            for timestamp, data in result_dict.items()
        ])
        
        # Convert datetime strings to pandas datetime objects
        df['datetime'] = pd.to_datetime(df['datetime'])
        
        # Sort by datetime
        return df.sort_values('datetime').reset_index(drop=True)
      
      # Example usage
      github_url = "https://github.com/sumtyme-ade/sample_data/tree/main/sample/spy_etf_1min.csv"
      df = download_github_data(github_url).tail(5003)
      
      # Get the last datetime as forecast date
      forecast_date = df['datetime'].iloc[-1]
      
      # Set the time interval between data points
      interval = 1 
      
      # Set the unit of time for the interval (options: seconds, minutes, days)
      interval_unit = "minutes"
      
      # Set the reasoning mode (options: proactive or reactive)
      reasoning_mode = "reactive"
      
      # Send request to API
      task_ids = post_request(df, interval, interval_unit, reasoning_mode)
        
    ```
  </Accordion>
</AccordionGroup>

## Sandbox API Response

<AccordionGroup>
  <Accordion title="Response">
    ```python
      {'task_id': 'task_id_6ed2f11b761d4eb589b1a223efb802d5', 'status': 'processing', 'tasks_ahead': 12}
        
    ```
  </Accordion>
</AccordionGroup>

## Retrieve Analysis

<AccordionGroup>
  <Accordion title="Using Log File">
    ```python
    
    
    import pandas as pd
    import requests
    
    def check_task_status(task_id):
      """Check the status of a submitted task"""
      api_endpoint = f"https://www.sumtyme.com/results/{task_id}"
      
      # Make the API request
      response = requests.get(api_endpoint)
      
      # Check if the request was successful (status code 200)
      if response.status_code == 200:
          result_data = response.json()
          
          # Check if processing is complete
          if "status" in result_data and result_data["status"] == "complete":
              return result_data
      
      # If we get here, either the request failed or status wasn't complete
      print(f"Failed to retrieve task status for {task_id}: {response.status_code}")
      return None
    
    def dict_to_dataframe(response_dict):
      """Transform response dictionary to dataframe more efficiently"""
      # Extract the result dictionary
      result_dict = response_dict['result']
      
      # Create the DataFrame directly from the dictionary
      df = pd.DataFrame([
          {'datetime': timestamp, 'trend_identified': data['trend_identified']}
          for timestamp, data in result_dict.items()
      ])
      
      # Convert datetime strings to pandas datetime objects
      df['datetime'] = pd.to_datetime(df['datetime'])
      
      # Sort by datetime
      return df.sort_values('datetime').reset_index(drop=True)
    
    def get_analysis(dataset, save_filename):
      """Process the dataset and check task statuses"""
      # Create a copy of the dataset to update
      updated_dataset = dataset.copy()
      
      # Pre-allocate the 'checked' column with default value
      updated_dataset['checked'] = 'Not processed'
      
      # Process each row in the dataset
      for i in dataset.index:
          try:
              # Extract data for current row
              task_id = str(dataset.loc[i, 'task_id'])
              forecast_date = pd.to_datetime(dataset.loc[i, 'forecast_date'])
              
              # Get analysis results
              analysis_results = check_task_status(task_id)
              
              # Process results if available
              if analysis_results is not None and 'result' in analysis_results:
                  # Convert results to DataFrame
                  df_results = dict_to_dataframe(analysis_results)
                  
                  # Check if dataframe has data
                  if not df_results.empty:
                      # Get the last datetime and trend in the results
                      last_datetime = df_results['datetime'].iloc[-1]
                      trend = df_results['trend_identified'].iloc[-1]
                      
                      # Update the 'checked' column based on datetime match
                      if last_datetime == forecast_date:
                          updated_dataset.loc[i, 'checked'] = trend
                      else:
                          updated_dataset.loc[i, 'checked'] = 'No'
                  else:
                      updated_dataset.loc[i, 'checked'] = 'Empty results'
              else:
                  updated_dataset.loc[i, 'checked'] = 'No results'
                  
          except Exception as e:
              # Improved error handling with exception details
              print(f"Error processing task_id {task_id}: {str(e)}")
              updated_dataset.loc[i, 'checked'] = 'Error'
      
      # Save the updated dataset
      updated_dataset.to_csv(save_filename, index=False)
      print(f"Processing complete. Results saved to {save_filename}")
    
    filename = "spy_1_min_task_ids"
    input_file = f"{filename}.csv"
    save_filename = f"{filename}_checked.csv"
        
    # Load the dataset
    dataset = pd.read_csv(input_file)
    
    get_analysis(dataset, save_filename)
      
        
    ```
  </Accordion>
  <Accordion title="Using Task ID">
    ```python
    
    
    import pandas as pd
    import requests
    
    def check_task_status(task_id):
      """Check the status of a submitted task"""
      api_endpoint = f"https://www.sumtyme.com/results/{task_id}"
      
      # Make the API request
      response = requests.get(api_endpoint)
      
      # Check if the request was successful (status code 200)
      if response.status_code == 200:
          result_data = response.json()
          
          # Check if processing is complete
          if "status" in result_data and result_data["status"] == "complete":
              return result_data
    
          elif "status" in result_data and result_data["status"] == "processing":
               print(f"{task_id}: Still processing") 
               return None
      
      # If we get here, either the request failed or status wasn't complete
      print(f"Failed to retrieve task status for {task_id}: {response.status_code}")
      return None
    
    def dict_to_dataframe(response_dict):
      """Transform response dictionary to dataframe more efficiently"""
      # Extract the result dictionary
      result_dict = response_dict['result']
      
      # Create the DataFrame directly from the dictionary
      df = pd.DataFrame([
          {'datetime': timestamp, 'trend_identified': data['trend_identified']}
          for timestamp, data in result_dict.items()
      ])
      
      # Convert datetime strings to pandas datetime objects
      df['datetime'] = pd.to_datetime(df['datetime'])
      
      # Sort by datetime
      return df.sort_values('datetime').reset_index(drop=True)
    
              
    
    task_id = ""
    
    response_dict = check_task_status(task_id)
    
    if response_dict is not None:
    
      final = dict_to_dataframe(response_dict)
    
      final.to_csv("sumtyme_analysis.csv",index=False)
    
        
    ```
  </Accordion>
</AccordionGroup>

## Plot Forecasts

<AccordionGroup>
  <Accordion title="Merge Price Data and Log File/Saved DataFrame">
    ```python
    
        
    ```
  </Accordion>
  <Accordion title="Plot Data">
    ```python
    
    import plotly.graph_objects as go
    from plotly.subplots import make_subplots
    import pandas as pd
    
    def create_line_chart_with_signals(df, name):
        """
        Create a full-screen trading signals chart with close price line and positioned arrows.
        
        Args:
            df (pd.DataFrame): DataFrame with Datetime, Close, and trend_identified columns
        """
        # Data validation and cleaning
        if not isinstance(df, pd.DataFrame):
            raise ValueError("Input must be a pandas DataFrame")
            
        required_cols = ['datetime', 'close', 'trend_identified']
        if not all(col in df.columns for col in required_cols):
            raise ValueError(f"DataFrame must contain columns: {required_cols}")
        
        # Ensure Datetime is properly formatted and sort
        df = df.copy()
        df['Datetime'] = pd.to_datetime(df['datetime']).dt.strftime("%Y-%m-%d %H:%M:%S")
        df = df.sort_values('datetime')
        print(df)
        # Create figure
        fig = make_subplots(specs=[[{"secondary_y": True}]])
        
        # Add line chart for close prices
        fig.add_trace(
            go.Scatter(
                x=df['datetime'],
                y=df['close'],
                mode='lines',
                name="Close Price",
                line=dict(
                    color='#2C3E50',
                    width=2
                )
            ),
            secondary_y=False,
        )
      
        # Calculate offset for arrow positioning
        price_range = df['high'].max() - df['low'].min()
        arrow_offset = price_range * 0.0  # 2% of price range for arrow positioning
      
        # Configure signals with error handling
        signal_configs = [
            # (signal value, name, color, symbol, offset direction)
            (1, 'Bullish Trend', '#7CFC00', 'triangle-up', -1),  # Below candle
            (-1, 'Bearish Trend', '#FF0000', 'triangle-down', 1)  # Above candle
        ]
        
        # Add signal markers with positioned arrows
        for signal, signal_name, color, symbol, offset_dir in signal_configs:
            signal_df = df[df['trend_identified'] == signal]
            if not signal_df.empty:
                # Calculate arrow positions based on Close price
                y_positions = signal_df['close'] + (arrow_offset * offset_dir)
                
                fig.add_trace(
                    go.Scatter(
                        x=signal_df['datetime'],
                        y=y_positions,
                        mode='markers',
                        name=signal_name,
                        marker=dict(
                            symbol=symbol,
                            size=12,
                            color=color,
                            opacity=0.7,
                        ),
                        hovertemplate='Signal: ' + signal_name + '<br>' +
                                    'Price: %{y:.2f}<br>' +
                                    '%{x}<extra></extra>'
                    ),
                    secondary_y=False,
                )
      
        # Optimize y-axis range with additional padding for arrows
        close_min = df['close'].min()
        close_max = df['close'].max()
        price_range = close_max - close_min
        padding = price_range * 0.05  # 5% padding
        y_range = [
            close_min - padding,
            close_max + padding
        ]
        
        # Create custom x-axis ticks with just first, middle, and last
        first_date = df['datetime'].iloc[0]
        middle_date = df['datetime'].iloc[len(df) // 2]
        last_date = df['datetime'].iloc[-1]
        
        custom_ticks = [first_date, middle_date, last_date]
        
        # Update layout for full screen
        fig.update_layout(
            title=dict(
                text=f'{name}',
                x=0.5,
                y=0.98,
                xanchor='center',
                yanchor='top',
                font=dict(size=20)
            ),
            plot_bgcolor='white',
            paper_bgcolor='white',
            hovermode='x unified',
            height=1200,
            width=None,
            margin=dict(l=40, r=20, t=50, b=60),  # Increased bottom margin for horizontal dates
            legend=dict(
                bgcolor='rgba(255, 255, 255, 0.9)',
                bordercolor='black',
                borderwidth=1,
                orientation='h',
                yanchor='top',
                y=0.98,
                xanchor='left',
                x=0.02,
                font=dict(size=12),
                itemsizing='constant'
            ),
            showlegend=True,
            xaxis_rangeslider_visible=False
        )
      
        # Update axes with custom ticks and horizontal date format
        fig.update_xaxes(
            title_text="Time",
            showgrid=True,
            gridwidth=1,
            gridcolor='rgba(211,211,211,0.2)',
            zeroline=False,
            showline=True,
            linewidth=1,
            linecolor='black',
            tickfont=dict(size=16),
            tickangle=0,  # Horizontal text
            tickmode='array',
            tickvals=custom_ticks,
            tickformat='%Y-%m-%d %H:%M',
            type='category',
        )
      
        fig.update_yaxes(
            title_text="Price",
            showgrid=True,
            gridwidth=1,
            gridcolor='rgba(211,211,211,0.2)',
            zeroline=False,
            showline=True,
            linewidth=1,
            linecolor='black',
            tickprefix='',
            tickformat='.1f',
            tickfont=dict(size=16),
            range=y_range,
            secondary_y=False
        )
      
        return fig
    
    filename = "sumtyme_predictions"
    
    df = pd.read_csv(f"{filename}.csv")
    
    fig = create_line_chart_with_signals(df,f"{filename}")
    
    fig.show()
    
    
        
    ```
  </Accordion>
</AccordionGroup>

## Full Script

<AccordionGroup>
  <Accordion title="Single API Call">
    ```python
      import requests
      import pandas as pd
      import io
      import os
      from datetime import datetime
      
      def download_github_data(url):
          # Convert GitHub repo URL to raw content URL
          if "github.com" in url and "/blob/" not in url and "/tree/" in url:
              # For /tree/ links, convert to raw
              url = url.replace("github.com", "raw.githubusercontent.com")
              url = url.replace("/tree/", "/")
          elif "github.com" in url and "/blob/" in url:
              # For /blob/ links, convert to raw
              url = url.replace("github.com", "raw.githubusercontent.com")
              url = url.replace("/blob/", "/")
              
          print(f"Downloading from: {url}")
          
          response = requests.get(url)
          if response.status_code == 200:
              return pd.read_csv(io.StringIO(response.text))
          else:
              raise Exception(f"Failed to download data: {response.status_code}")
      
      def time_series_dict(df, interval, interval_unit, reasoning_mode):
          """
          Converts a DataFrame with OHLC price data into a dictionary format.
          
          Parameters:
          df (DataFrame): DataFrame containing datetime and OHLC price columns
          interval (int): The time interval between data points
          interval_unit (str): The unit of time for intervals (seconds, minutes, days)
          reasoning_mode (str): Reasoning strategy (proactive or reactive)
          
          Returns:
          dict: Dictionary with lists of datetime and price data along with metadata
          """
          return {
              "datetime": df['datetime'].tolist(),  # Convert datetime column to list
              "open": df['open'].tolist(),          # Convert open prices to list
              "high": df['high'].tolist(),          # Convert high prices to list
              "low": df['low'].tolist(),            # Convert low prices to list
              "close": df['close'].tolist(),        # Convert close prices to list
              "interval": interval,                 # Time frequency value
              "interval_unit": interval_unit,       # Time unit (seconds, minutes, days)
              "reasoning_mode": reasoning_mode      # Reasoning approach (proactive/reactive)
          }
      
      def log_forecast_check(task_id, forecast_date, log_file="sumtyme_task_ids.log"):
          """
          Logs a forecast check to a CSV file.
          
          Parameters:
          - task_id (str): The ID of the task 
          - forecast_date (str): The date of the forecast
          - log_file (str): Path to the log file, defaults to "sumtyme_task_ids.log"
          """
          current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
          
          # Create log file with header if it doesn't exist
          if not os.path.exists(log_file):
              with open(log_file, 'w') as f:
                  f.write("timestamp,forecast_date,task_id,checked\n")
      
          # Write to log file
          with open(log_file, 'a') as f:
              f.write(f"{current_time},{forecast_date},{task_id},blank\n")
          
          return True
      
      def time_series_dict(df, interval, interval_unit, reasoning_mode):
              """
              Converts a DataFrame with OHLC price data into a dictionary format.
              
              Parameters:
              df (DataFrame): DataFrame containing datetime and OHLC price columns
              interval (int): The time interval between data points
              interval_unit (str): The unit of time for intervals (seconds, minutes, days)
              reasoning_mode (str): Reasoning strategy (proactive or reactive)
              
              Returns:
              dict: Dictionary with lists of datetime and price data along with metadata
              """
              return {
                  "datetime": df['datetime'].tolist(),  # Convert datetime column to list
                  "open": df['open'].tolist(),          # Convert open prices to list
                  "high": df['high'].tolist(),          # Convert high prices to list
                  "low": df['low'].tolist(),            # Convert low prices to list
                  "close": df['close'].tolist(),        # Convert close prices to list
                  "interval": interval,                 # Time frequency value
                  "interval_unit": interval_unit,       # Time unit (seconds, minutes, days)
                  "reasoning_mode": reasoning_mode      # Reasoning approach (proactive/reactive)
              }
      
      def post_request(df,interval,interval_unit,reasoning_mode):
      
        # Prepare request
        api_endpoint = f"https://www.sumtyme.com/shared/v1/reasoning-model-ts"
        headers = {"Content-Type": "application/json"}
        
        # Create payload from data
        payload = time_series_dict(df,interval,interval_unit,reasoning_mode)
        
        # Send POST request to API
        response = requests.post(api_endpoint, json=payload, headers=headers)
      
        if response.status_code != 200:
                  print(f"API request failed for {forecast_date} with status code {response.status_code}: {response.text}")
        else:
          return response.json()
      
      def check_task_status(task_id):
      
        """Check the status of a submitted task"""
      
        api_endpoint = f"https://www.sumtyme.com/results/{task_id}"
        
        # Make the API request
        response = requests.get(api_endpoint)
        
        # Check if the request was successful (status code 200)
        if response.status_code == 200:
            result_data = response.json()
            
            # Check if processing is complete
            if "status" in result_data and result_data["status"] == "complete":
                return result_data
      
            elif "status" in result_data and result_data["status"] == "processing":
                 print(f"{task_id}: Still processing") 
                 return None
        
        # If we get here, either the request failed or status wasn't complete
        print(f"Failed to retrieve task status for {task_id}: {response.status_code}")
        return None
      
      def dict_to_dataframe(response_dict):
        """
        Transform response dictionary to dataframe more efficiently
        """
        # Extract the result dictionary
        result_dict = response_dict['result']
        
        # Create the DataFrame directly from the dictionary
        df = pd.DataFrame([
            {'datetime': timestamp, 'trend_identified': data['trend_identified']}
            for timestamp, data in result_dict.items()
        ])
        
        # Convert datetime strings to pandas datetime objects
        df['datetime'] = pd.to_datetime(df['datetime'])
        
        # Sort by datetime
        return df.sort_values('datetime').reset_index(drop=True)
      
      # Example usage
      github_url = "https://github.com/sumtyme-ade/sample_data/tree/main/sample/spy_etf_1min.csv"
      df = download_github_data(github_url).tail(5000)
      
      # Get the last datetime as forecast date
      forecast_date = df['datetime'].iloc[-1]
      
      # Set the time interval between data points
      interval = 1 
      
      # Set the unit of time for the interval (options: seconds, minutes, days)
      interval_unit = "minutes"
      
      # Set the reasoning mode (options: proactive or reactive)
      reasoning_mode = "reactive"
      
      # Send request to API
      response = post_request(df,interval,interval_unit,reasoning_mode)
      
      # Process response if successful
      if response:
          print(response)
          task_id = response.get("task_id")
      
          log_forecast_check(task_id,forecast_date)
        
    ```
  </Accordion>
  <Accordion title="Multiple API Calls">
    ```python
    
        
    ```
  </Accordion>
</AccordionGroup>

## Performance Evaluation

<AccordionGroup>
  <Accordion title="Predictive Lead Time">
    Quantify how many minutes/hours/days before major market events the model provides reliable signals, demonstrating its ability to anticipate systemic shifts before they fully develop in the market.
  </Accordion>
  <Accordion title="Reaction Speed">
    Measure how quickly the model adjusts after sudden market shocks, calculated as the time between a shock event and when the model's predictions catch up to the new reality.
  </Accordion>
  <Accordion title="Time Horizon Alignment">
    Verify that predictions for neighbouring time periods (e.g. 1 hour, 2 hour, 3 hour) consistently build upon each other without logical contradictions or conflicting signals.
  </Accordion>
</AccordionGroup>

## Key Concepts

<AccordionGroup>
  <Accordion title="Cross-Timeframe Connectivity">
    The reasoning model operates as a unified system where predictions across multiple time horizons work together rather than independently. This integrated approach reveals how market movements propagate across timeframes, uncovering interconnected relationships that traditional single-timeframe approaches fundamentally cannot detect.

    <img
      height="200"
      src="/images/Unified System Architecture.png"
    />
  </Accordion>
  <Accordion title="High-to-Low Frequency Propagation Assumption">
    The reasoning model assumes that all price movements originate in high-frequency time series before cascading into lower-frequency time series. It therefore analyses price action and only returns trends that it believes will translate into lower frequency timeframes.
  </Accordion>
  <Accordion title="Interpreting Trend Context">
    The reasoning model begins its analysis with as little as 10 historical data points. Your results include both the forecast (if identified) and the trend context that shaped it, all in one view. This helps users understand if predictions occur at the beginning, middle, or end of broader trends, making forecasts easier to understand and increasing your confidence in decisions.
  </Accordion>
  <Accordion title="Interpreting Trend Signals">
    Each forecast should be interpreted within its trend context: the first signal in a consecutive trend marks the start of a trend, while consecutive forecasts in the same direction indicate the consistency of the current trend.
  </Accordion>
  <Accordion title="Immediate Insights, Custom Optimisation">
    The reasoning model delivers immediate market insights without requiring market-specific training data. While predictive out of the box, it can be fine-tuned to optimise performance for specific time horizons through customised post-training. This flexibility allows users to incorporate multiple timeframes or any combination of traditional and alternative datasets of their choosing.
  </Accordion>
  <Accordion title="Sandbox Queue System">
    The sandbox processes API requests in a FIFO (first-in, first-out) queue, with each request taking approximately 5 seconds to complete. Wait times may extend during high-usage periods. For testing without queue delays, contact us at [team@sumtyme.ai](mailto:team@sumtyme.ai) to arrange a dedicated environment.
  </Accordion>
</AccordionGroup>